{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Automated Reasoning","text":"<p>A distributed system for solving automated reasoning problems at scale.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Monorepo</li> <li>Project Management via uv</li> <li>Dockerized services</li> <li>API Gateway FastAPI service</li> <li>Solver Worker multiprocess service</li> <li>RabbitMQ message broker as task queue</li> <li>Redis as data store</li> </ul>"},{"location":"#architecture","title":"Architecture","text":""},{"location":"#documentation","title":"Documentation","text":"<p>The documentation for this project can be found here.</p>"},{"location":"#to-dos","title":"To-Dos","text":"<ul> <li>Problem Implementations</li> <li>[x] sudoku (puzzle)</li> <li>[ ] hashi (puzz;e)</li> <li>[ ] maze-cover (puzzle)</li> <li>[ ] balsort</li> </ul> <p>giraycoskun</p>"},{"location":"problems/","title":"Problem Catalog","text":"Problem Solver Type Status Notes Sudoku IP \ud83d\udfe2 Implemented Grid puzzle with row/column/box uniqueness Hashi (Bridges) - \ud83d\udfe1 Planned Connect islands with bridges under degree constraints Maze Cover - \ud83d\udfe1 Planned Path/cover puzzle Balsort - \ud83d\udfe1 Planned Sorting/stacking puzzle"},{"location":"api/app/","title":"API Reference","text":""},{"location":"api/app/#api.app","title":"app","text":"<p>API Gateway for Solver Service.</p>"},{"location":"api/app/#api.app.root","title":"root","text":"<pre><code>root() -&gt; dict\n</code></pre> <p>Get API information and metadata.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary containing API name, version, description, documentation   link, environment, developer info, and contact details.</p> Source code in <code>src/api/app.py</code> <pre><code>@app.get(\"/\")\ndef root() -&gt; dict:\n    \"\"\"Get API information and metadata.\n\n    Returns:\n        dict: Dictionary containing API name, version, description, documentation\n              link, environment, developer info, and contact details.\n    \"\"\"\n    return {\n        \"API Name\": \"Automated Reasoning API\",\n        \"API Version\": __version__,\n        \"Description\": \"An automated reasoning API (FastAPI Framework) via IP, CSP and search algorithms.\",\n        \"Documentation\": \"https://giraycoskun.github.io/automated-reasoning-api/\",\n        \"Environment\": ENVIRONMENT,\n        \"Developer\": \"giraycoskun\",\n        \"Contact\": \"giraycoskun.dev@gmail.com\",\n    }\n</code></pre>"},{"location":"api/app/#api.app.ping","title":"ping  <code>async</code>","text":"<pre><code>ping() -&gt; str\n</code></pre> <p>Health check endpoint.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>\"pong\" response to indicate the API is running and healthy.</p> Source code in <code>src/api/app.py</code> <pre><code>@app.get(\"/ping\")\nasync def ping() -&gt; str:\n    \"\"\"Health check endpoint.\n\n    Returns:\n        str: \"pong\" response to indicate the API is running and healthy.\n    \"\"\"\n    return \"pong\"\n</code></pre>"},{"location":"clients/rabbitmq_client/","title":"RabbitMQ Client Reference","text":""},{"location":"clients/rabbitmq_client/#clients.rabbitmq_client","title":"rabbitmq_client","text":"<p>RabbitMQ async client for puzzle job queuing.</p>"},{"location":"clients/rabbitmq_client/#clients.rabbitmq_client.init_rabbitmq","title":"init_rabbitmq  <code>async</code>","text":"<pre><code>init_rabbitmq() -&gt; None\n</code></pre> <p>Initialize RabbitMQ connection and declare queue.</p> Source code in <code>src/clients/rabbitmq_client.py</code> <pre><code>async def init_rabbitmq() -&gt; None:\n    \"\"\"Initialize RabbitMQ connection and declare queue.\"\"\"\n    global connection, channel\n    try:\n        rabbitmq_url = f\"amqp://{RABBITMQ_USERNAME}:{RABBITMQ_PASSWORD}@{RABBITMQ_HOST}:{RABBITMQ_PORT}/\"\n        connection = await aio_pika.connect_robust(rabbitmq_url) # type: ignore\n        channel = await connection.channel() # type: ignore\n        await channel.declare_queue(RABBITMQ_PROBLEMS_QUEUE_NAME, durable=True) # type: ignore\n        logger.success(\"RabbitMQ connected successfully\")\n    except Exception as e:\n        logger.error(\"RabbitMQ connection failed: {}\", str(e))\n        raise\n</code></pre>"},{"location":"clients/rabbitmq_client/#clients.rabbitmq_client.close_rabbitmq","title":"close_rabbitmq  <code>async</code>","text":"<pre><code>close_rabbitmq() -&gt; None\n</code></pre> <p>Close RabbitMQ connection.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If closing the connection fails.</p> Source code in <code>src/clients/rabbitmq_client.py</code> <pre><code>async def close_rabbitmq() -&gt; None:\n    \"\"\"Close RabbitMQ connection.\n\n    Raises:\n        Exception: If closing the connection fails.\n    \"\"\"\n    global connection, channel\n    try:\n        if channel:\n            await channel.close()\n        if connection:\n            await connection.close()\n        logger.info(\"RabbitMQ closed successfully\")\n    except Exception as e:\n        logger.error(\"Error closing RabbitMQ: {error}\", error=str(e))\n        raise\n</code></pre>"},{"location":"clients/rabbitmq_client/#clients.rabbitmq_client.enqueue_problem","title":"enqueue_problem  <code>async</code>","text":"<pre><code>enqueue_problem(problem: Problem) -&gt; None\n</code></pre> <p>Publish a Problem instance to the queue using msgpack serialization.</p> <p>Parameters:</p> Name Type Description Default <code>problem</code> <code>Problem</code> <p>The Problem instance to enqueue.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If channel is not initialized.</p> <code>Exception</code> <p>If publishing fails.</p> Source code in <code>src/clients/rabbitmq_client.py</code> <pre><code>async def enqueue_problem(problem: Problem) -&gt; None:\n    \"\"\"Publish a Problem instance to the queue using msgpack serialization.\n\n    Args:\n        problem: The Problem instance to enqueue.\n\n    Raises:\n        RuntimeError: If channel is not initialized.\n        Exception: If publishing fails.\n    \"\"\"\n    global channel\n    if channel is None:\n        raise RuntimeError(\"RabbitMQ channel not initialized. Call init_rabbitmq() first.\")\n\n    try:\n        payload = _serialize_problem(problem)\n        await channel.default_exchange.publish(\n            aio_pika.Message(body=payload),\n            routing_key=RABBITMQ_PROBLEMS_QUEUE_NAME\n        )\n        logger.info(\"Problem object enqueued: {problem_id}\", problem_id=problem.problem_id)\n    except Exception as e:\n        logger.error(\"Error enqueuing problem object: {error}\", error=str(e))\n        raise\n</code></pre>"},{"location":"clients/rabbitmq_client/#clients.rabbitmq_sync_client","title":"rabbitmq_sync_client","text":"<p>Synchronous RabbitMQ client for solver workers.</p>"},{"location":"clients/rabbitmq_client/#clients.rabbitmq_sync_client.create_rabbitmq_connection","title":"create_rabbitmq_connection","text":"<pre><code>create_rabbitmq_connection() -&gt; pika.BlockingConnection\n</code></pre> <p>Create a new blocking RabbitMQ connection.</p> <p>Returns:</p> Type Description <code>BlockingConnection</code> <p>pika.BlockingConnection: A new connection to RabbitMQ.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If connection fails.</p> Source code in <code>src/clients/rabbitmq_sync_client.py</code> <pre><code>def create_rabbitmq_connection() -&gt; pika.BlockingConnection:\n    \"\"\"\n    Create a new blocking RabbitMQ connection.\n\n    Returns:\n        pika.BlockingConnection: A new connection to RabbitMQ.\n\n    Raises:\n        Exception: If connection fails.\n    \"\"\"\n    try:\n        credentials = pika.PlainCredentials(RABBITMQ_USERNAME, RABBITMQ_PASSWORD)\n        parameters = pika.ConnectionParameters(\n            host=RABBITMQ_HOST,\n            port=int(RABBITMQ_PORT),\n            credentials=credentials,\n            heartbeat=600,\n            blocked_connection_timeout=300,\n        )\n        connection = pika.BlockingConnection(parameters)\n        logger.info(\"RabbitMQ blocking connection created successfully\")\n        return connection\n    except Exception as e:\n        logger.error(f\"Failed to create RabbitMQ connection: {e}\")\n        raise\n</code></pre>"},{"location":"clients/rabbitmq_client/#clients.rabbitmq_sync_client.create_rabbitmq_channel","title":"create_rabbitmq_channel","text":"<pre><code>create_rabbitmq_channel(\n    connection: BlockingConnection,\n) -&gt; pika.adapters.blocking_connection.BlockingChannel\n</code></pre> <p>Create a channel from an existing RabbitMQ connection.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>BlockingConnection</code> <p>An active RabbitMQ connection.</p> required <p>Returns:</p> Type Description <code>BlockingChannel</code> <p>pika.adapters.blocking_connection.BlockingChannel: A new channel.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If channel creation fails.</p> Source code in <code>src/clients/rabbitmq_sync_client.py</code> <pre><code>def create_rabbitmq_channel(connection: pika.BlockingConnection) -&gt; \"pika.adapters.blocking_connection.BlockingChannel\":\n    \"\"\"\n    Create a channel from an existing RabbitMQ connection.\n\n    Args:\n        connection: An active RabbitMQ connection.\n\n    Returns:\n        pika.adapters.blocking_connection.BlockingChannel: A new channel.\n\n    Raises:\n        Exception: If channel creation fails.\n    \"\"\"\n    try:\n        channel = connection.channel()\n        logger.info(\"RabbitMQ channel created successfully\")\n        return channel\n    except Exception as e:\n        logger.error(f\"Failed to create RabbitMQ channel: {e}\")\n        raise\n</code></pre>"},{"location":"clients/rabbitmq_client/#clients.rabbitmq_sync_client.setup_consumer_channel","title":"setup_consumer_channel","text":"<pre><code>setup_consumer_channel(\n    channel: BlockingChannel, prefetch_count: int = 1\n) -&gt; None\n</code></pre> <p>Configure a channel for consuming messages.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>BlockingChannel</code> <p>The channel to configure.</p> required <code>prefetch_count</code> <code>int</code> <p>Number of messages to prefetch (default: 1 for fair dispatch).</p> <code>1</code> Source code in <code>src/clients/rabbitmq_sync_client.py</code> <pre><code>def setup_consumer_channel(channel: \"pika.adapters.blocking_connection.BlockingChannel\", prefetch_count: int = 1) -&gt; None:\n    \"\"\"\n    Configure a channel for consuming messages.\n\n    Args:\n        channel: The channel to configure.\n        prefetch_count: Number of messages to prefetch (default: 1 for fair dispatch).\n    \"\"\"\n    # Declare queue (idempotent)\n    channel.queue_declare(queue=RABBITMQ_PROBLEMS_QUEUE_NAME, durable=True)\n\n    # Set QoS for fair dispatch\n    channel.basic_qos(prefetch_count=prefetch_count)\n\n    logger.info(f\"Consumer channel configured with prefetch_count={prefetch_count}\")\n</code></pre>"},{"location":"clients/rabbitmq_client/#clients.rabbitmq_sync_client.close_rabbitmq_connection","title":"close_rabbitmq_connection","text":"<pre><code>close_rabbitmq_connection(\n    connection: Optional[BlockingConnection],\n    channel: Optional[BlockingChannel] = None,\n) -&gt; None\n</code></pre> <p>Safely close RabbitMQ channel and connection.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Optional[BlockingConnection]</code> <p>The connection to close.</p> required <code>channel</code> <code>Optional[BlockingChannel]</code> <p>Optional channel to close first.</p> <code>None</code> Source code in <code>src/clients/rabbitmq_sync_client.py</code> <pre><code>def close_rabbitmq_connection(\n    connection: Optional[pika.BlockingConnection],\n    channel: Optional[\"pika.adapters.blocking_connection.BlockingChannel\"] = None\n) -&gt; None:\n    \"\"\"\n    Safely close RabbitMQ channel and connection.\n\n    Args:\n        connection: The connection to close.\n        channel: Optional channel to close first.\n    \"\"\"\n    if channel:\n        try:\n            channel.close()\n            logger.info(\"RabbitMQ channel closed\")\n        except Exception as e:\n            logger.warning(f\"Error closing RabbitMQ channel: {e}\")\n\n    if connection:\n        try:\n            connection.close()\n            logger.info(\"RabbitMQ connection closed\")\n        except Exception as e:\n            logger.warning(f\"Error closing RabbitMQ connection: {e}\")\n</code></pre>"},{"location":"clients/redis_client/","title":"REDIS CLient Reference","text":""},{"location":"clients/redis_client/#clients.redis_client","title":"redis_client","text":"<p>Async Redis client helpers for storing problems efficiently.</p>"},{"location":"clients/redis_client/#clients.redis_client.save_to_redis","title":"save_to_redis  <code>async</code>","text":"<pre><code>save_to_redis(key: str, value: str) -&gt; None\n</code></pre> <p>Save a key-value pair to Redis.</p> Source code in <code>src/clients/redis_client.py</code> <pre><code>async def save_to_redis(key: str, value: str) -&gt; None:\n    \"\"\"Save a key-value pair to Redis.\"\"\"\n    global redis\n    if redis:\n        await redis.set(key, value)\n        logger.info(f\"Saved to Redis: {key}\")\n</code></pre>"},{"location":"clients/redis_client/#clients.redis_client.save_problem_redis","title":"save_problem_redis  <code>async</code>","text":"<pre><code>save_problem_redis(problem: Problem) -&gt; str\n</code></pre> <p>Persist a Problem instance in Redis using msgpack.</p> <p>Parameters:</p> Name Type Description Default <code>problem</code> <code>Problem</code> <p>The Problem instance to store.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The Redis key used (problem_id).</p> Source code in <code>src/clients/redis_client.py</code> <pre><code>async def save_problem_redis(problem: Problem) -&gt; str:\n    \"\"\"Persist a Problem instance in Redis using msgpack.\n\n    Args:\n        problem: The Problem instance to store.\n\n    Returns:\n        str: The Redis key used (problem_id).\n    \"\"\"\n    global redis\n    if redis is None:\n        raise RuntimeError(\"Redis is not initialized. Call init_redis() first.\")\n\n    payload = _serialize_problem(problem)\n    await redis.set(problem.problem_id, payload)\n    logger.info(f\"Saved problem to Redis: {problem.problem_id}\")\n    return problem.problem_id\n</code></pre>"},{"location":"clients/redis_client/#clients.redis_client.load_problem_redis","title":"load_problem_redis  <code>async</code>","text":"<pre><code>load_problem_redis(problem_id: str) -&gt; Problem | None\n</code></pre> <p>Retrieve a Problem payload from Redis.</p> <p>Parameters:</p> Name Type Description Default <code>problem_id</code> <code>str</code> <p>The UUID key used when saving the problem.</p> required <p>Returns:</p> Type Description <code>Problem | None</code> <p>dict | None: Decoded problem payload or None if missing.</p> Source code in <code>src/clients/redis_client.py</code> <pre><code>async def load_problem_redis(problem_id: str) -&gt; Problem | None:\n    \"\"\"Retrieve a Problem payload from Redis.\n\n    Args:\n        problem_id: The UUID key used when saving the problem.\n\n    Returns:\n        dict | None: Decoded problem payload or None if missing.\n    \"\"\"\n    global redis\n    if redis is None:\n        raise RuntimeError(\"Redis is not initialized. Call init_redis() first.\")\n\n    blob = await redis.get(problem_id)\n    if blob is None:\n        return None\n    return _deserialize_problem(blob)\n</code></pre>"},{"location":"clients/redis_client/#clients.redis_client.check_id_exists","title":"check_id_exists  <code>async</code>","text":"<pre><code>check_id_exists(problem_id: str) -&gt; bool\n</code></pre> <p>Check if a problem ID exists in Redis.</p> <p>Parameters:</p> Name Type Description Default <code>problem_id</code> <code>str</code> <p>The UUID key to check.</p> required <p>Returns:     bool: True if the ID exists, False otherwise.</p> Source code in <code>src/clients/redis_client.py</code> <pre><code>async def check_id_exists(problem_id: str) -&gt; bool:\n    \"\"\"Check if a problem ID exists in Redis.\n\n    Args:\n        problem_id: The UUID key to check.\n    Returns:\n        bool: True if the ID exists, False otherwise.\n    \"\"\"\n    global redis\n    if redis is None:\n        raise RuntimeError(\"Redis is not initialized. Call init_redis() first.\")\n    exists = await redis.exists(problem_id)\n    return exists == 1\n</code></pre>"},{"location":"clients/redis_client/#clients.redis_sync_client","title":"redis_sync_client","text":"<p>Synchronous Redis client for solver workers.</p>"},{"location":"clients/redis_client/#clients.redis_sync_client.create_redis_client","title":"create_redis_client","text":"<pre><code>create_redis_client() -&gt; redis.Redis\n</code></pre> <p>Create a new synchronous Redis client.</p> <p>Returns:</p> Type Description <code>Redis</code> <p>redis.Redis: A new Redis client instance.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If connection or ping fails.</p> Source code in <code>src/clients/redis_sync_client.py</code> <pre><code>def create_redis_client() -&gt; redis.Redis:  # type: ignore\n    \"\"\"\n    Create a new synchronous Redis client.\n\n    Returns:\n        redis.Redis: A new Redis client instance.\n\n    Raises:\n        Exception: If connection or ping fails.\n    \"\"\"\n    try:\n        redis_url = f\"redis://{REDIS_HOST_URL}:{REDIS_PORT}\"\n        client: redis.Redis = redis.Redis.from_url(redis_url, decode_responses=False)  # type: ignore\n\n        # Test connection\n        client.ping()\n        logger.info(\"Redis sync client connected successfully\")\n        return client\n    except Exception as e:\n        logger.error(f\"Failed to create Redis client: {e}\")\n        raise\n</code></pre>"},{"location":"clients/redis_client/#clients.redis_sync_client.save_solution_to_redis","title":"save_solution_to_redis","text":"<pre><code>save_solution_to_redis(\n    client: Redis, solution: Solution\n) -&gt; None\n</code></pre> <p>Save a solution to Redis and update the problem with solution data.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Redis</code> <p>Redis client instance.</p> required <code>solution</code> <code>Solution</code> <p>The Solution object containing problem_id, solution_data, and status.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If client is None.</p> <code>Exception</code> <p>If save fails.</p> Source code in <code>src/clients/redis_sync_client.py</code> <pre><code>def save_solution_to_redis(\n    client: redis.Redis,  # type: ignore\n    solution: Solution,\n) -&gt; None:\n    \"\"\"\n    Save a solution to Redis and update the problem with solution data.\n\n    Args:\n        client: Redis client instance.\n        solution: The Solution object containing problem_id, solution_data, and status.\n\n    Raises:\n        RuntimeError: If client is None.\n        Exception: If save fails.\n    \"\"\"\n    if client is None:\n        raise RuntimeError(\"Redis client is None\")\n\n    try:\n        # Load and update the problem with solution data\n        problem_bytes = client.get(solution.problem_id)\n        if problem_bytes and isinstance(problem_bytes, bytes):\n            from clients.util import _deserialize_problem, _serialize_problem\n\n            problem = _deserialize_problem(problem_bytes)\n            problem.solution = solution.solution_data\n            problem.status = solution.status\n\n            # Save updated problem back to Redis\n            updated_problem_bytes = _serialize_problem(problem)\n            client.set(solution.problem_id, updated_problem_bytes)\n            logger.info(f\"Problem {solution.problem_id} updated with solution\")\n        else:\n            logger.warning(\n                f\"Problem {solution.problem_id} not found in Redis, only solution saved\"\n            )\n\n    except Exception as e:\n        logger.error(f\"Failed to save solution to Redis: {e}\")\n        raise\n</code></pre>"},{"location":"clients/redis_client/#clients.redis_sync_client.close_redis_client","title":"close_redis_client","text":"<pre><code>close_redis_client(client: Optional[Redis]) -&gt; None\n</code></pre> <p>Safely close Redis client connection.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Optional[Redis]</code> <p>The Redis client to close.</p> required Source code in <code>src/clients/redis_sync_client.py</code> <pre><code>def close_redis_client(client: Optional[redis.Redis]) -&gt; None:  # type: ignore\n    \"\"\"\n    Safely close Redis client connection.\n\n    Args:\n        client: The Redis client to close.\n    \"\"\"\n    if client:\n        try:\n            client.close()\n            logger.info(\"Redis client closed\")\n        except Exception as e:\n            logger.warning(f\"Error closing Redis client: {e}\")\n</code></pre>"},{"location":"getting-started/configuration/","title":"Configuration","text":""},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/usage/","title":"Usage","text":""},{"location":"getting-started/usage/#development","title":"Development","text":"<pre><code>uvicorn src.app:app --reload\n</code></pre>"},{"location":"getting-started/usage/#serve-documentation","title":"Serve Documentation","text":"<pre><code>PYTHONPATH=./src uv run mkdocs serve --livereload\n</code></pre>"},{"location":"solver/main/","title":"Solver Reference","text":""},{"location":"solver/main/#solver.main","title":"main","text":"<p>Multi-process solver service - main dispatches worker subprocesses that consume from queue.</p>"},{"location":"solver/main/#solver.main.SolverService","title":"SolverService","text":"<p>Main service that spawns independent worker subprocesses.</p> Source code in <code>src/solver/main.py</code> <pre><code>class SolverService:\n    \"\"\"Main service that spawns independent worker subprocesses.\"\"\"\n\n    def __init__(self, num_workers: int = SOLVER_NUM_WORKERS):\n        self.num_workers = num_workers\n        self.workers: List[multiprocessing.Process] = []\n        self.shutdown_event = multiprocessing.Event()\n\n    def _signal_handler(self, signum, frame):\n        \"\"\"Handle shutdown signals gracefully.\"\"\"\n        logger.warning(f\"Received signal {signum}, initiating shutdown...\")\n        self.shutdown_event.set()\n\n    def start(self):\n        \"\"\"Start all worker processes.\"\"\"\n        # Register signal handlers\n        signal.signal(signal.SIGINT, self._signal_handler)\n        signal.signal(signal.SIGTERM, self._signal_handler)\n\n        logger.info(f\"Starting solver service with {self.num_workers} workers\")\n\n        # Spawn worker processes\n        for worker_id in range(self.num_workers):\n            worker = Worker(\n                worker_id=worker_id,\n                shutdown_event=self.shutdown_event\n            )\n            process = multiprocessing.Process(\n                target=worker.run,\n                name=f\"Worker-{worker_id}\"\n            )\n            process.start()\n            self.workers.append(process)\n            logger.info(f\"Started worker process {worker_id} (PID: {process.pid})\")\n\n        # Wait for all workers to complete\n        try:\n            for worker in self.workers:\n                worker.join()\n        except KeyboardInterrupt:\n            logger.warning(\"Keyboard interrupt received\")\n            self.shutdown_event.set()\n\n        logger.info(\"All workers have stopped. Service shutdown complete.\")\n\n    def stop(self):\n        \"\"\"Stop all worker processes gracefully.\"\"\"\n        logger.info(\"Stopping all workers...\")\n        self.shutdown_event.set()\n\n        # Give workers time to finish current tasks\n        for worker in self.workers:\n            worker.join(timeout=10)\n            if worker.is_alive():\n                logger.warning(f\"Terminating worker {worker.name}\")\n                worker.terminate()\n                worker.join()\n</code></pre>"},{"location":"solver/main/#solver.main.SolverService.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Start all worker processes.</p> Source code in <code>src/solver/main.py</code> <pre><code>def start(self):\n    \"\"\"Start all worker processes.\"\"\"\n    # Register signal handlers\n    signal.signal(signal.SIGINT, self._signal_handler)\n    signal.signal(signal.SIGTERM, self._signal_handler)\n\n    logger.info(f\"Starting solver service with {self.num_workers} workers\")\n\n    # Spawn worker processes\n    for worker_id in range(self.num_workers):\n        worker = Worker(\n            worker_id=worker_id,\n            shutdown_event=self.shutdown_event\n        )\n        process = multiprocessing.Process(\n            target=worker.run,\n            name=f\"Worker-{worker_id}\"\n        )\n        process.start()\n        self.workers.append(process)\n        logger.info(f\"Started worker process {worker_id} (PID: {process.pid})\")\n\n    # Wait for all workers to complete\n    try:\n        for worker in self.workers:\n            worker.join()\n    except KeyboardInterrupt:\n        logger.warning(\"Keyboard interrupt received\")\n        self.shutdown_event.set()\n\n    logger.info(\"All workers have stopped. Service shutdown complete.\")\n</code></pre>"},{"location":"solver/main/#solver.main.SolverService.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stop all worker processes gracefully.</p> Source code in <code>src/solver/main.py</code> <pre><code>def stop(self):\n    \"\"\"Stop all worker processes gracefully.\"\"\"\n    logger.info(\"Stopping all workers...\")\n    self.shutdown_event.set()\n\n    # Give workers time to finish current tasks\n    for worker in self.workers:\n        worker.join(timeout=10)\n        if worker.is_alive():\n            logger.warning(f\"Terminating worker {worker.name}\")\n            worker.terminate()\n            worker.join()\n</code></pre>"},{"location":"solver/main/#solver.main.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>Entry point for the solver service.</p> Source code in <code>src/solver/main.py</code> <pre><code>def main():\n    \"\"\"Entry point for the solver service.\"\"\"\n    # Set multiprocessing start method\n    multiprocessing.set_start_method('spawn', force=True)\n\n    logger.info(\"=\" * 60)\n    logger.info(\"SOLVER SERVICE STARTING\")\n    logger.info(\"=\" * 60)\n\n    service = SolverService(num_workers=SOLVER_NUM_WORKERS)\n\n    try:\n        service.start()\n    except Exception as e:\n        logger.error(f\"Fatal error in solver service: {e}\")\n        service.stop()\n        raise\n    finally:\n        logger.info(\"Solver service terminated\")\n</code></pre>"},{"location":"solver/worker/","title":"Workers","text":"<p>:: solver.worker</p>"}]}